"use strict"
var NNTFunctions=NNTFunctions||{}
NNTFunctions.util={assert:function(t,i){if(!t)throw i||"Assertation failed"},getOption:function(t,i,n){return void 0===t?n:void 0!==t[i]?t[i]:n},convertRange:function(t,i,n){for(var e=[],r=0,o=t.length;r<o;r++)e.push((t[r]-i[0])*(n[1]-n[0])/(i[1]-i[0])+n[0])
return e},similarity:function(t,i){NNTFunctions.util.assert(t.length===i.length,"Array lengths do not match")
for(var n=0,e=0,r=0,o=0,l=t.length;o<l;o++)n+=Math.pow(t[o],2),e+=Math.pow(i[o],2),r+=t[o]*i[o]
return r/(Math.sqrt(n)*Math.sqrt(e))},random:function(t,i){return Math.random()*(i-t)+t},randArr:function(t,i){for(var n=[],e=0;e<t;e++){for(var r=[],o=0;o<i;o++)r.push(NNTFunctions.util.random(-2,2))
n.push(r)}return n}},NNTFunctions.NNTNode=function(t){this.point=t,this.parent=null,this.left=null,this.right=null,this.index=-1,this.isTerminal=!1},NNTFunctions.NeuralNTree=function(t){this.rootNode=null,this.alpha=NNTFunctions.util.getOption(t,"learningRate",.01),this.terminals={},this.index=0,this.min=NNTFunctions.util.getOption(t,"scaleMin",-1),this.max=NNTFunctions.util.getOption(t,"scaleMax",1),this.size=NNTFunctions.util.getOption(t,"size",1e3),this.merge=NNTFunctions.util.getOption(t,"merge",8),this.dimensions=NNTFunctions.util.getOption(t,"dimensions",3),this.nodes=[]
var i=NNTFunctions.util.randArr(this.size,this.dimensions)
this.initTree(i),this.postOrder(this.rootNode)},NNTFunctions.NeuralNTree.prototype.setMerge=function(t){this.merge=Math.log2(t)-1},NNTFunctions.NeuralNTree.prototype.postOrder=function(t){if(null!==t&&void 0!==t){this.postOrder(t.left),this.postOrder(t.right)
var i=this.index
t.index=i,this.nodes[i]=t,this.index++,t.isTerminal&&(this.terminals[i]=t)}},NNTFunctions.NeuralNTree.prototype.initTree=function(t){return this._initTree(t,0,t.length-1)},NNTFunctions.NeuralNTree.prototype._initTree=function(t,i,n){if(i>n)return null
var e=Math.round((i+n)/2),r=new NNTFunctions.NNTNode(t[e])
return null===this.rootNode&&(this.rootNode=r),r.left=this._initTree(t,i,e-1),null!==r.left&&(r.left.parent=r),r.right=this._initTree(t,e+1,n),null!==r.right&&(r.right.parent=r),null===r.left&&null===r.right&&(r.isTerminal=!0),r},NNTFunctions.NeuralNTree.prototype.backwardTrain=function(t){t=NNTFunctions.util.convertRange(t,[this.min,this.max],[-2,2])
var i=null
for(var n in this.terminals){null===i&&(i=this.terminals[n])
NNTFunctions.util.similarity(t,i.point)>NNTFunctions.util.similarity(t,this.terminals[n].point)&&(i=this.terminals[n])}for(;this.rootNode!==i;)this.levelUpdate(i,t),i=i.parent},NNTFunctions.NeuralNTree.prototype.levelOrder=function(t){var i=[]
if(null===t)return i
var n=[]
for(n.push(t);n.length>0;){for(var e=[],r=[];n.length>0;){t=n.shift(),r.push(t)
var o=t.left,l=t.right
null!==o&&e.push(o),null!==l&&e.push(l)}i.push(r),n=e}return i},NNTFunctions.NeuralNTree.prototype.levelUpdate=function(t,i){for(var n=this.levelOrder(t),e=n.length,r=0,o=n.length;r<o;r++)for(var l=0,s=n[r].length;l<s;l++)if(null!==n[r][l])for(var u=0,N=n[r][l].point.length;u<N;u++)n[r][l].point[u]=this.update(n[r][l].point[u],i[u],(r+1)/(e+1))},NNTFunctions.NeuralNTree.prototype.update=function(t,i,n){return t+this.alpha*(1/n)*(i-t)},NNTFunctions.NeuralNTree.prototype.cluster=function(t){t=NNTFunctions.util.convertRange(t,[this.min,this.max],[-2,2])
for(var i=this.rootNode;!i.isTerminal;)if(null!==i.left&&null!==i.right){var n=NNTFunctions.util.similarity(t,i.left.point),e=NNTFunctions.util.similarity(t,i.right.point)
i=n>=e?i.left:i.right}else i=null===i.left&&null!==i.right?i.right:i.left
return i},NNTFunctions.NeuralNTree.prototype.forwardTrain=function(t){t=NNTFunctions.util.convertRange(t,[this.min,this.max],[-2,2])
for(var i=this.rootNode;null!==i;)if(null!==i.left&&null!==i.right){var n=NNTFunctions.util.similarity(t,i.left.point),e=NNTFunctions.util.similarity(t,i.right.point)
i=n>=e?i.left:i.right,this.levelUpdate(i,t)}else i=null!==i.left&&null===i.right?i.left:i.right},NNTFunctions.NeuralNTree.prototype.mergeClusters=function(){for(var t=this.levelOrder(this.rootNode),i=0;i<t[this.merge].length;i++)for(var n=this.levelOrder(t[this.merge][i]),e=n[0][0].index,r=1;r<n.length;r++)for(var o=0;o<n[r].length;o++)n[r][o]&&(n[r][o].mergeIndex=e)
t=this.levelOrder(this.rootNode)},NNTFunctions.NeuralNTree.prototype.nodesByIndex=function(t){return this.nodes[t]}
